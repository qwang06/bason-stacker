{"version":3,"file":"app.js","mappings":"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","sources":["webpack://bason-stacker/./src/ts/Coin.ts","webpack://bason-stacker/./src/ts/Events.ts","webpack://bason-stacker/./src/ts/Game.ts","webpack://bason-stacker/./src/ts/Scenes/Boot.ts","webpack://bason-stacker/./src/ts/Scenes/GameOver.ts","webpack://bason-stacker/./src/ts/Scenes/MainGame.ts","webpack://bason-stacker/./src/ts/Scenes/MainMenu.ts","webpack://bason-stacker/./src/ts/Scenes/MainSettings.ts","webpack://bason-stacker/./src/ts/Scenes/Preloader.ts","webpack://bason-stacker/./src/ts/Scenes/SplashScreen.ts","webpack://bason-stacker/./src/ts/Scenes/UI.ts","webpack://bason-stacker/./src/ts/Utilities.ts","webpack://bason-stacker/external var \"Phaser\"","webpack://bason-stacker/webpack/bootstrap","webpack://bason-stacker/webpack/startup"],"sourcesContent":["export class Coin extends Phaser.Physics.Arcade.Image {\r\n\tconstructor(\r\n\t\tscene: Phaser.Scene,\r\n\t\tx: number,\r\n\t\ty: number,\r\n\t\tcollideWorldBounds: boolean\r\n\t) {\r\n\t\tsuper(scene, x, y, \"coin\");\r\n\t\tthis.setScale(0.15);\r\n\t\tscene.physics.add.existing(this);\r\n\t\tscene.add.existing(this);\r\n\t\t// this.setVelocity(300, 100);\r\n\t\t// this.setBounce(1, 0);\r\n\t\tif (collideWorldBounds) {\r\n\t\t\tthis.setCollideWorldBounds(true, 0, 0, true);\r\n\t\t} else {\r\n\t\t\tthis.setCollideWorldBounds(false);\r\n\t\t}\r\n\t\tthis.setOrigin(0);\r\n\t\tthis.setGravityY(0);\r\n\t}\r\n}\r\n\r\nexport default Coin;\r\n","const events = new Phaser.Events.EventEmitter();\r\n\r\nexport default events;\r\n","import \"phaser\";\r\nimport Boot from \"./Scenes/Boot\";\r\nimport Preloader from \"./Scenes/Preloader\";\r\nimport MainMenu from \"./Scenes/MainMenu\";\r\nimport SplashScreen from \"./Scenes/SplashScreen\";\r\nimport Utilities from \"./Utilities\";\r\nimport MainGame from \"./Scenes/MainGame\";\r\nimport MainSettings from \"./Scenes/MainSettings\";\r\nimport UI from \"./Scenes/UI\";\r\nimport GameOver from \"./Scenes/GameOver\";\r\n\r\nconst gameConfig: Phaser.Types.Core.GameConfig = {\r\n\twidth: 375,\r\n\theight: 667,\r\n\ttype: Phaser.AUTO,\r\n\tparent: \"content\",\r\n\ttitle: \"Bason Stacker\",\r\n\tphysics: {\r\n\t\tdefault: \"arcade\",\r\n\t\tarcade: {\r\n\t\t\tgravity: { x: 0, y: 300 },\r\n\t\t},\r\n\t},\r\n\trender: {\r\n\t\tpixelArt: false,\r\n\t},\r\n\tscale: {\r\n\t\tmode: Phaser.Scale.FIT,\r\n\t\tautoCenter: Phaser.Scale.CENTER_BOTH,\r\n\t},\r\n};\r\n\r\nexport default class Game extends Phaser.Game {\r\n\tconstructor(config: Phaser.Types.Core.GameConfig) {\r\n\t\tUtilities.LogSceneMethodEntry(\"Game\", \"constructor\");\r\n\r\n\t\tsuper(config);\r\n\r\n\t\tthis.scene.add(Boot.Name, Boot);\r\n\t\tthis.scene.add(Preloader.Name, Preloader);\r\n\t\tthis.scene.add(SplashScreen.Name, SplashScreen);\r\n\t\tthis.scene.add(MainMenu.Name, MainMenu);\r\n\t\tthis.scene.add(MainGame.Name, MainGame);\r\n\t\tthis.scene.add(MainSettings.Name, MainSettings);\r\n\t\tthis.scene.add(UI.Name, UI);\r\n\t\tthis.scene.add(GameOver.Name, GameOver);\r\n\t\tthis.scene.start(Boot.Name);\r\n\t}\r\n}\r\n\r\nwindow.onload = (): void => {\r\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n\tconst game = new Game(gameConfig);\r\n};\r\n","import Preloader from \"./Preloader\";\r\nimport Utilities from \"../Utilities\";\r\n\r\nexport default class Boot extends Phaser.Scene {\r\n\t/**\r\n\t * Unique name of the scene.\r\n\t */\r\n\tpublic static Name = \"Boot\";\r\n\r\n\tpublic preload(): void {\r\n\t\t// Preload as needed.\r\n\t}\r\n\r\n\tpublic create(): void {\r\n\t\tUtilities.LogSceneMethodEntry(\"Boot\", \"create\");\r\n\r\n\t\tthis.scene.start(Preloader.Name);\r\n\t}\r\n}\r\n","import MainGame from \"./MainGame\";\r\n\r\n// Create game over scene\r\nexport default class GameOver extends Phaser.Scene {\r\n\tpublic static Name = \"GameOver\";\r\n\toverlay: Phaser.GameObjects.Rectangle;\r\n\tscore: number;\r\n\r\n\tpublic create({ score }): void {\r\n\t\t// this.scene.pause();\r\n\t\tthis.score = score;\r\n\r\n\t\tthis.setupUI();\r\n\t}\r\n\r\n\tsetupUI() {\r\n\t\t// create a faded overlay over entire screen\r\n\t\tthis.overlay = this.add\r\n\t\t\t.rectangle(\r\n\t\t\t\t0,\r\n\t\t\t\t0,\r\n\t\t\t\tthis.cameras.main.width,\r\n\t\t\t\tthis.cameras.main.height,\r\n\t\t\t\t0x000000,\r\n\t\t\t\t0.5\r\n\t\t\t)\r\n\t\t\t.setOrigin(0, 0);\r\n\r\n\t\t// add game over text to center of screen\r\n\t\tconst text = this.add\r\n\t\t\t.text(this.cameras.main.centerX, this.cameras.main.centerY, \"Game Over\", {\r\n\t\t\t\tfontSize: \"40px\",\r\n\t\t\t\tcolor: \"#ffffff\",\r\n\t\t\t\tfontFamily: \"VT323, monospace\",\r\n\t\t\t})\r\n\t\t\t.setOrigin(0.5);\r\n\t\t// add score to above game over text\r\n\t\tconst scoreText = this.add\r\n\t\t\t.text(\r\n\t\t\t\tthis.cameras.main.centerX,\r\n\t\t\t\tthis.cameras.main.centerY - 50,\r\n\t\t\t\t`Score: ${this.score}`,\r\n\t\t\t\t{\r\n\t\t\t\t\tfontSize: \"20px\",\r\n\t\t\t\t\tcolor: \"#ffffff\",\r\n\t\t\t\t\tfontFamily: \"VT323, monospace\",\r\n\t\t\t\t}\r\n\t\t\t)\r\n\t\t\t.setOrigin(0.5);\r\n\r\n\t\t// add text to restart game\r\n\t\tconst restartText = this.add\r\n\t\t\t.text(\r\n\t\t\t\tthis.cameras.main.centerX,\r\n\t\t\t\tthis.cameras.main.centerY + 50,\r\n\t\t\t\t\"Restart\",\r\n\t\t\t\t{\r\n\t\t\t\t\tfontSize: \"40px\",\r\n\t\t\t\t\tcolor: \"#ffffff\",\r\n\t\t\t\t\tfontFamily: \"VT323, monospace\",\r\n\t\t\t\t}\r\n\t\t\t)\r\n\t\t\t.setOrigin(0.5)\r\n\t\t\t.setInteractive({ useHandCursor: true });\r\n\r\n\t\t// add click event to restart game\r\n\t\trestartText.on(\"pointerdown\", () => {\r\n\t\t\tconsole.log(\"Restarting game\");\r\n\t\t\tthis.scene.start(MainGame.Name);\r\n\t\t\tthis.scene.stop(GameOver.Name);\r\n\t\t});\r\n\r\n\t\t// on hover change color of text\r\n\t\trestartText.on(\"pointerover\", () => {\r\n\t\t\trestartText.setColor(\"#00ffff\");\r\n\t\t});\r\n\r\n\t\t// on hover out change color of text back to white\r\n\t\trestartText.on(\"pointerout\", () => {\r\n\t\t\trestartText.setColor(\"#ffffff\");\r\n\t\t});\r\n\t}\r\n}\r\n","import Utilities from \"../Utilities\";\r\nimport UI from \"./UI\";\r\nimport GameOver from \"./GameOver\";\r\nimport Coin from \"../Coin\";\r\nimport events from \"../Events\";\r\n\r\nconst COIN_SPACING = 0; // spacing between coins so they don't overlap\r\nconst COIN_SPEED = 300; // speed at which coins move\r\nconst NUM_ROWS_BEFORE_SCROLL = 3; // number of rows before scrolling effect is triggered\r\n// when the map is \"scrolling\", the coins may not line up perfectly with the grid\r\n// this constant is the maximum difference in y position between coins that are considered to be in the same column\r\nconst POTENTIAL_MOVING_DIFFERENCE = 10;\r\n\r\nexport default class MainGame extends Phaser.Scene {\r\n\t/**\r\n\t * Unique name of the scene.\r\n\t */\r\n\tpublic static Name = \"MainGame\";\r\n\tmovingCoins: Phaser.Physics.Arcade.Image[];\r\n\tstackedCoins: Phaser.Physics.Arcade.Image[];\r\n\tbottomCoins: Phaser.Physics.Arcade.Image[];\r\n\tcoinsToSpawn: number;\r\n\ttimesStacked: number;\r\n\tbackgrounds: Phaser.GameObjects.Image[];\r\n\tcurrentBgIndex: number;\r\n\r\n\tpublic init(): void {\r\n\t\tthis.movingCoins = [];\r\n\t\tthis.stackedCoins = [];\r\n\t\tthis.bottomCoins = [];\r\n\t\tthis.coinsToSpawn = 3;\r\n\t\tthis.timesStacked = 0;\r\n\t}\r\n\r\n\tpublic create(): void {\r\n\t\tUtilities.LogSceneMethodEntry(\"MainGame\", \"create\");\r\n\r\n\t\tthis.scene.launch(UI.Name);\r\n\t\tthis.setupBackground();\r\n\t\tthis.setupCoins();\r\n\t\tthis.setupClickEvents();\r\n\t}\r\n\r\n\tpublic update(): void {\r\n\t\tlet topStackedCoin;\r\n\t\t// coins should be kept in a grid formation that starts at the bottom of the screen\r\n\t\t// row 0 is the bottom row and its y position is the height of the screen minus the height of a coin\r\n\t\t// row 1 is the row above row 0 and its y position is the y position of row 0 minus the height of a coin\r\n\t\tthis.stackedCoins.forEach((coin) => {\r\n\t\t\t// keep coins from moving when they hit the ground or other coins\r\n\t\t\tif (coin.body.velocity.y === 0) {\r\n\t\t\t\tcoin.y = Math.round(coin.y);\r\n\t\t\t\t// fix coin y positions to grid\r\n\t\t\t\tconst row = Math.round(\r\n\t\t\t\t\t(this.cameras.main.height - coin.y) / coin.displayHeight\r\n\t\t\t\t);\r\n\t\t\t\tcoin.y = Math.round(\r\n\t\t\t\t\tthis.cameras.main.height - row * coin.displayHeight\r\n\t\t\t\t);\r\n\t\t\t}\r\n\r\n\t\t\tif (!topStackedCoin || coin.y < topStackedCoin.y) {\r\n\t\t\t\ttopStackedCoin = coin;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tif (this.movingCoins.length) {\r\n\t\t\tconst firstCoin = this.movingCoins[0];\r\n\t\t\tthis.movingCoins.forEach((coin, index) => {\r\n\t\t\t\t// sync moving coins' x position with the first coin in the moving coins array\r\n\t\t\t\tcoin.x = firstCoin.x + (coin.displayWidth + COIN_SPACING) * index;\r\n\t\t\t\t// sync moving coins' y position to always be above the top stacked coin\r\n\t\t\t\tif (topStackedCoin) {\r\n\t\t\t\t\tcoin.setVelocityY(0);\r\n\t\t\t\t\tconsole.log(topStackedCoin.y, coin.y);\r\n\t\t\t\t\tcoin.y = Math.round(topStackedCoin.y - coin.displayHeight);\r\n\t\t\t\t\tconsole.log(topStackedCoin.y, coin.y);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\tcheckBoundaries(body, up, down, left, right) {\r\n\t\tif (left || right) {\r\n\t\t\tthis.movingCoins.forEach((coin) => {\r\n\t\t\t\tcoin.setVelocityX(COIN_SPEED * (left ? 1 : -1));\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\tsetupBackground() {\r\n\t\tconst cameraWidth = this.cameras.main.width;\r\n\t\tconst cameraHeight = this.cameras.main.height;\r\n\r\n\t\tthis.physics.world.bounds.width = cameraWidth;\r\n\t\tthis.physics.world.bounds.height = cameraHeight;\r\n\r\n\t\t// add sticky background image to scene\r\n\t\tconst bg = this.add.image(0, 0, \"BG\").setOrigin(0);\r\n\t\t// scale background image to fit screen\r\n\t\tbg.setScale(Math.max(cameraWidth / bg.width, cameraHeight / bg.height));\r\n\t\tbg.x = 0 - (bg.displayWidth - cameraWidth) / 2;\r\n\t\tbg.setScrollFactor(0, 1);\r\n\r\n\t\t// add background image to scene\r\n\t\tconst bg2 = this.add.image(0, 0, \"cult_underground2\").setOrigin(0);\r\n\t\t// scale background image to fit screen\r\n\t\tbg2.setScale(Math.max(cameraWidth / bg2.width, cameraHeight / bg2.height));\r\n\t\tbg2.x = 0 - (bg2.displayWidth - cameraWidth) / 2;\r\n\t\tbg2.setScrollFactor(0, 1);\r\n\r\n\t\tconst bg3 = this.add.image(0, 0, \"bason_cave_lw3\").setOrigin(0);\r\n\t\t// scale background image to fit screen\r\n\t\tbg3.setScale(Math.max(cameraWidth / bg3.width, cameraHeight / bg3.height));\r\n\t\tbg3.x = 0 - (bg3.displayWidth - cameraWidth) / 2;\r\n\t\t// set background image to out of view\r\n\t\tbg3.y = this.cameras.main.height;\r\n\t\tbg3.setScrollFactor(0, 1);\r\n\r\n\t\tconst bg4 = this.add.image(0, 0, \"FINAL_CAMPSCENE\").setOrigin(0);\r\n\t\t// scale background image to fit screen\r\n\t\tbg4.setScale(Math.max(cameraWidth / bg4.width, cameraHeight / bg4.height));\r\n\t\tbg4.x = 0 - (bg4.displayWidth - cameraWidth) / 2;\r\n\t\t// set background image to out of view\r\n\t\tbg4.y = this.cameras.main.height;\r\n\t\tbg4.setScrollFactor(0, 1);\r\n\r\n\t\tthis.backgrounds = [bg2, bg3, bg4];\r\n\t\tthis.currentBgIndex = 0;\r\n\t}\r\n\r\n\tsetupClickEvents() {\r\n\t\tthis.input.on(\"pointerdown\", this.coinsStack.bind(this));\r\n\t\tthis.physics.world.on(\"worldbounds\", this.checkBoundaries.bind(this));\r\n\t}\r\n\r\n\tsetupCoins() {\r\n\t\tthis.spawnNewCoins();\r\n\t}\r\n\r\n\tcoinsStack() {\r\n\t\t// stop all coins from moving\r\n\t\tconst firstCoin = this.movingCoins[0];\r\n\t\tconst offset = firstCoin.x % firstCoin.displayWidth;\r\n\t\tconst left = offset < firstCoin.displayWidth / 2;\r\n\t\tconst direction = firstCoin.body.velocity.x > 0 ? \"right\" : \"left\";\r\n\t\tlet stacked = 0;\r\n\r\n\t\tthis.movingCoins.forEach((coin) => {\r\n\t\t\tcoin.setVelocity(0, 0);\r\n\t\t\tcoin.x = coin.x - (left ? offset : offset - coin.displayWidth);\r\n\t\t\tcoin.y = Math.round(coin.y);\r\n\r\n\t\t\t// check if there is a stacked coin below coin with POTENTIAL_MOVING_DIFFERENCE\r\n\t\t\tconst coinBelow = this.stackedCoins.find((stackedCoin) => {\r\n\t\t\t\tconsole.log({\r\n\t\t\t\t\ty: coin.y,\r\n\t\t\t\t\tstackedY: stackedCoin.y,\r\n\t\t\t\t\tdiff: Math.abs(coin.y + coin.displayWidth - stackedCoin.y),\r\n\t\t\t\t});\r\n\t\t\t\treturn (\r\n\t\t\t\t\tcoin.x === stackedCoin.x &&\r\n\t\t\t\t\tMath.abs(coin.y + coin.displayWidth - stackedCoin.y) <\r\n\t\t\t\t\t\tPOTENTIAL_MOVING_DIFFERENCE\r\n\t\t\t\t);\r\n\t\t\t});\r\n\t\t\tif (coinBelow) {\r\n\t\t\t\tstacked++;\r\n\t\t\t}\r\n\t\t});\r\n\t\tconst willOverflow =\r\n\t\t\tfirstCoin.x + firstCoin.displayWidth * this.movingCoins.length >\r\n\t\t\tthis.cameras.main.width;\r\n\t\tif (willOverflow) {\r\n\t\t\t// remove world bounds collision from overflowed coin\r\n\t\t\tconst lastCoin = this.movingCoins[this.movingCoins.length - 1];\r\n\t\t\t// TODO: better solution for how to handle coins that overflow\r\n\t\t\tlastCoin.x = this.cameras.main.width - lastCoin.displayWidth / 2;\r\n\t\t\tlastCoin.setCollideWorldBounds(false);\r\n\t\t}\r\n\r\n\t\tif (this.stackedCoins.length) {\r\n\t\t\tthis.coinsToSpawn = stacked;\r\n\r\n\t\t\tif (stacked > 0) {\r\n\t\t\t\tthis.timesStacked++;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tthis.timesStacked++;\r\n\t\t}\r\n\r\n\t\t// only collide with stacked coins when falling down\r\n\t\tthis.physics.add.collider(\r\n\t\t\tthis.movingCoins,\r\n\t\t\tthis.stackedCoins,\r\n\t\t\t(obj1: any, obj2: any) => {\r\n\t\t\t\tobj1.setVelocityY(0);\r\n\t\t\t\tobj2.setVelocityY(0);\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\t// add all moving coins to stacked coins array\r\n\t\tthis.stackedCoins.push(...this.movingCoins);\r\n\t\t// clear moving coins array\r\n\t\tthis.movingCoins = [];\r\n\t\t// spawn new coins\r\n\t\tthis.spawnNewCoins(firstCoin.x, direction);\r\n\t\t// update score\r\n\t\tevents.emit(\"coinStacked\", this.timesStacked);\r\n\t\tif (this.timesStacked > NUM_ROWS_BEFORE_SCROLL) {\r\n\t\t\tthis.simulateScrolling();\r\n\t\t}\r\n\t}\r\n\r\n\t// handles logic for spawning new coins\r\n\tspawnNewCoins(x = 0, direction = \"right\") {\r\n\t\tif (this.coinsToSpawn === 0) {\r\n\t\t\tconsole.log(\"game over\");\r\n\t\t\tthis.scene.launch(GameOver.Name, { score: this.timesStacked });\r\n\t\t\tthis.scene.pause();\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlet yPosToSpawn: number;\r\n\r\n\t\tif (this.stackedCoins.length) {\r\n\t\t\t// get the last coin in the stacked coins array\r\n\t\t\tconst lastCoin = this.stackedCoins[this.stackedCoins.length - 1];\r\n\t\t\t// get the y position of the last coin\r\n\t\t\tyPosToSpawn = lastCoin.y - lastCoin.displayHeight;\r\n\t\t}\r\n\r\n\t\tfor (let i = 0; i < this.coinsToSpawn; i++) {\r\n\t\t\tconst coin = new Coin(this, 0, 0, true);\r\n\t\t\tcoin.x = i * (coin.displayWidth + COIN_SPACING) + x;\r\n\t\t\tif (yPosToSpawn) {\r\n\t\t\t\tcoin.y = yPosToSpawn;\r\n\t\t\t} else {\r\n\t\t\t\tcoin.y = this.cameras.main.height - coin.displayHeight;\r\n\t\t\t}\r\n\t\t\tthis.movingCoins.push(coin);\r\n\t\t}\r\n\r\n\t\tthis.movingCoins.forEach((coin) => {\r\n\t\t\tcoin.setVelocityX(COIN_SPEED * (direction === \"right\" ? 1 : -1));\r\n\t\t});\r\n\r\n\t\t// set collision between coins in moving coins array\r\n\t\t// this.movingCoins.forEach((coin) => {\r\n\t\t// \tthis.movingCoins.forEach((otherCoin) => {\r\n\t\t// \t\tif (coin !== otherCoin) {\r\n\t\t// \t\t\tthis.physics.add.collider(coin, otherCoin);\r\n\t\t// \t\t}\r\n\t\t// \t});\r\n\t\t// });\r\n\t}\r\n\r\n\t// simulate scrolling effect by moving all coins down\r\n\t// coins at the bottom of the screen are removed\r\n\tsimulateScrolling() {\r\n\t\t// find all coins that are at the bottom of the screen\r\n\t\tthis.bottomCoins = this.stackedCoins.filter((coin) => {\r\n\t\t\treturn (\r\n\t\t\t\tMath.round(coin.y + coin.displayHeight) === this.cameras.main.height\r\n\t\t\t);\r\n\t\t});\r\n\t\tif (!this.bottomCoins.length) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// remove collision with world bounds\r\n\t\tthis.bottomCoins.forEach((coinToScroll) => {\r\n\t\t\tcoinToScroll.setCollideWorldBounds(false);\r\n\t\t});\r\n\r\n\t\t// move background image down by the height of a coin with tween\r\n\t\tconst bg = this.backgrounds[this.currentBgIndex];\r\n\t\tconst coinHeight = this.bottomCoins[0].displayHeight;\r\n\t\tconst scrollDuration = 300;\r\n\t\tconst scrollY = coinHeight;\r\n\t\tthis.add.tween({\r\n\t\t\ttargets: bg,\r\n\t\t\ty: bg.y + scrollY,\r\n\t\t\tduration: scrollDuration,\r\n\t\t\tease: \"Linear\",\r\n\t\t\tonComplete: () => {\r\n\t\t\t\t// remove coins that are at the bottom of the screen\r\n\t\t\t\tthis.bottomCoins.forEach((coinToScroll) => {\r\n\t\t\t\t\tthis.stackedCoins = this.stackedCoins.filter((coin) => {\r\n\t\t\t\t\t\treturn coin !== coinToScroll;\r\n\t\t\t\t\t});\r\n\t\t\t\t\tcoinToScroll.destroy();\r\n\t\t\t\t});\r\n\t\t\t},\r\n\t\t});\r\n\r\n\t\t// if current background image is at the bottom of the screen, show next background image\r\n\t\tif (bg.y >= this.cameras.main.height) {\r\n\t\t\tthis.currentBgIndex++;\r\n\t\t\tthis.backgrounds[this.currentBgIndex].y = 0;\r\n\t\t}\r\n\t}\r\n}\r\n","import Utilities from \"../Utilities\";\r\nimport MainGame from \"./MainGame\";\r\nimport MainSettings from \"./MainSettings\";\r\n\r\nexport default class MainMenu extends Phaser.Scene {\r\n\t/**\r\n\t * Unique name of the scene.\r\n\t */\r\n\tpublic static Name = \"MainMenu\";\r\n\r\n\tpublic preload(): void {\r\n\t\t// Preload as needed.\r\n\t}\r\n\r\n\tpublic create(): void {\r\n\t\tUtilities.LogSceneMethodEntry(\"MainMenu\", \"create\");\r\n\t\tconst textYPosition = this.cameras.main.height / 3;\r\n\r\n\t\t// Add text \"Start\" to the screen.\r\n\t\tconst newGameText = this.add.text(\r\n\t\t\tthis.cameras.main.centerX,\r\n\t\t\ttextYPosition,\r\n\t\t\t\"Start\"\r\n\t\t);\r\n\t\tnewGameText\r\n\t\t\t.setFontFamily(\"monospace\")\r\n\t\t\t.setFontSize(40)\r\n\t\t\t.setFill(\"#fff\")\r\n\t\t\t.setAlign(\"center\")\r\n\t\t\t.setOrigin(0.5);\r\n\t\tnewGameText.setInteractive();\r\n\t\tnewGameText.on(\r\n\t\t\t\"pointerdown\",\r\n\t\t\t() => {\r\n\t\t\t\tthis.scene.start(MainGame.Name);\r\n\t\t\t},\r\n\t\t\tthis\r\n\t\t);\r\n\r\n\t\t// Add text \"Settings\" to the screen\r\n\t\tconst settingsText = this.add.text(\r\n\t\t\tthis.cameras.main.centerX,\r\n\t\t\ttextYPosition * 2,\r\n\t\t\t\"Settings\"\r\n\t\t);\r\n\t\tsettingsText.setOrigin(0.5);\r\n\t\tsettingsText.setFontFamily(\"monospace\").setFontSize(30).setFill(\"#fff\");\r\n\t\tsettingsText.setInteractive();\r\n\t\tsettingsText.on(\r\n\t\t\t\"pointerdown\",\r\n\t\t\t() => {\r\n\t\t\t\tthis.scene.start(MainSettings.Name);\r\n\t\t\t},\r\n\t\t\tthis\r\n\t\t);\r\n\t}\r\n\r\n\tpublic update(): void {\r\n\t\t// Update logic, as needed.\r\n\t}\r\n}\r\n","import Utilities from \"../Utilities\";\r\nimport MainMenu from \"./MainMenu\";\r\n\r\nexport default class MainSettings extends Phaser.Scene {\r\n\t/**\r\n\t * Unique name of the scene.\r\n\t */\r\n\tpublic static Name = \"MainSettings\";\r\n\r\n\tpublic create(): void {\r\n\t\tUtilities.LogSceneMethodEntry(\"MainSettings\", \"create\");\r\n\t\tconst startYPosition = this.cameras.main.height / 4;\r\n\t\tconst fontSize = 25;\r\n\r\n\t\t// Add a button to return to the main menu.\r\n\t\tconst backText = this.add.text(this.cameras.main.centerX, startYPosition * 2, \"Go Back\");\r\n\t\tbackText\r\n\t\t\t.setOrigin(0.5)\r\n\t\t\t.setFontFamily(\"monospace\").setFontSize(fontSize).setFill(\"#fff\")\r\n\t\t\t.setInteractive();\r\n\t\tbackText.on(\"pointerdown\", () => { this.scene.start(MainMenu.Name); }, this);\r\n\t}\r\n}\r\n","import SplashScreen from \"./SplashScreen\";\r\nimport MainGame from \"./MainGame\";\r\nimport MainMenu from \"./MainMenu\";\r\nimport Utilities from \"../Utilities\";\r\n\r\nexport default class Preloader extends Phaser.Scene {\r\n\t/**\r\n\t * Unique name of the scene.\r\n\t */\r\n\tpublic static Name = \"Preloader\";\r\n\r\n\tpublic preload(): void {\r\n\t\tthis.addProgressBar();\r\n\r\n\t\tthis.load.path = \"assets/\";\r\n\r\n\t\t// fonts\r\n\t\tthis.load.bitmapFont(\"arcade\", \"fonts/arcade.png\", \"fonts/arcade.xml\");\r\n\r\n\t\t// images\r\n\t\tthis.load.image(\"cult_underground2\");\r\n\t\tthis.load.image(\"BG\");\r\n\t\tthis.load.image(\"bason_cave_lw3\");\r\n\t\tthis.load.image(\"FINAL_CAMPSCENE\");\r\n\t\tthis.load.image(\"coin\", \"front_coin_flat.png\");\r\n\t}\r\n\r\n\tpublic create(): void {\r\n\t\tUtilities.LogSceneMethodEntry(\"Preloader\", \"create\");\r\n\r\n\t\t// this.scene.start(SplashScreen.Name);\r\n\t\tthis.scene.start(MainGame.Name);\r\n\t\t// this.scene.start(MainMenu.Name);\r\n\t}\r\n\r\n\tpublic update(): void {\r\n\t\t// preload handles updates to the progress bar, so nothing should be needed here.\r\n\t}\r\n\r\n\t/**\r\n\t * Adds a progress bar to the display, showing the percentage of assets loaded and their name.\r\n\t */\r\n\tprivate addProgressBar(): void {\r\n\t\tconst width = this.cameras.main.width;\r\n\t\tconst height = this.cameras.main.height;\r\n\t\t/** Customizable. This text color will be used around the progress bar. */\r\n\t\tconst outerTextColor = \"#ffffff\";\r\n\r\n\t\tconst progressBar = this.add.graphics();\r\n\t\tconst progressBox = this.add.graphics();\r\n\t\tprogressBox.fillStyle(0x222222, 0.8);\r\n\t\tprogressBox.fillRect(width / 4, height / 2 - 30, width / 2, 50);\r\n\r\n\t\tconst loadingText = this.make.text({\r\n\t\t\tx: width / 2,\r\n\t\t\ty: height / 2 - 50,\r\n\t\t\ttext: \"Loading...\",\r\n\t\t\tstyle: {\r\n\t\t\t\tfontFamily: \"VT323, monospace\",\r\n\t\t\t\tfontSize: \"20px\",\r\n\t\t\t\tcolor: outerTextColor,\r\n\t\t\t},\r\n\t\t});\r\n\t\tloadingText.setOrigin(0.5, 0.5);\r\n\r\n\t\tconst percentText = this.make.text({\r\n\t\t\tx: width / 2,\r\n\t\t\ty: height / 2 - 5,\r\n\t\t\ttext: \"0%\",\r\n\t\t\tstyle: {\r\n\t\t\t\tfontFamily: \"VT323, monospace\",\r\n\t\t\t\tfontSize: \"18px\",\r\n\t\t\t\tcolor: \"#ffffff\",\r\n\t\t\t},\r\n\t\t});\r\n\t\tpercentText.setOrigin(0.5, 0.5);\r\n\r\n\t\tconst assetText = this.make.text({\r\n\t\t\tx: width / 2,\r\n\t\t\ty: height / 2 + 50,\r\n\t\t\ttext: \"\",\r\n\t\t\tstyle: {\r\n\t\t\t\tfontFamily: \"VT323, monospace\",\r\n\t\t\t\tfontSize: \"18px\",\r\n\t\t\t\tcolor: outerTextColor,\r\n\t\t\t},\r\n\t\t});\r\n\r\n\t\tassetText.setOrigin(0.5, 0.5);\r\n\r\n\t\tthis.load.on(\"progress\", (value: number) => {\r\n\t\t\tpercentText.setText(parseInt(value * 100 + \"\", 10) + \"%\");\r\n\t\t\tprogressBar.clear();\r\n\t\t\tprogressBar.fillStyle(0xffffff, 1);\r\n\t\t\tprogressBar.fillRect(\r\n\t\t\t\twidth / 4 + 10,\r\n\t\t\t\theight / 2 - 30 + 10,\r\n\t\t\t\t(width / 2 - 10 - 10) * value,\r\n\t\t\t\t30\r\n\t\t\t);\r\n\t\t});\r\n\r\n\t\tthis.load.on(\"fileprogress\", (file: Phaser.Loader.File) => {\r\n\t\t\tassetText.setText(\"Loading asset: \" + file.key);\r\n\t\t});\r\n\r\n\t\tthis.load.on(\"complete\", () => {\r\n\t\t\tprogressBar.destroy();\r\n\t\t\tprogressBox.destroy();\r\n\t\t\tloadingText.destroy();\r\n\t\t\tpercentText.destroy();\r\n\t\t\tassetText.destroy();\r\n\t\t});\r\n\t}\r\n}\r\n","import Utilities from \"../Utilities\";\r\nimport MainMenu from \"./MainMenu\";\r\n\r\nexport default class SplashScreen extends Phaser.Scene {\r\n\t/**\r\n\t * Unique name of the scene.\r\n\t */\r\n\tpublic static Name = \"SplashScreen\";\r\n\r\n\tpublic preload(): void {\r\n\t\tthis.load.path = \"assets/\";\r\n\t}\r\n\r\n\tpublic create(): void {\r\n\t\tUtilities.LogSceneMethodEntry(\"SplashScreen\", \"create\");\r\n\r\n\t\tconst titleText = this.add.text(this.cameras.main.centerX, this.cameras.main.centerY * 0.5, \"Starter Project for Phaser 3 with TypeScript\")\r\n\t\t\t.setOrigin(0.5, 0)\r\n\t\t\t.setFontFamily(\"monospace\").setFontSize(26).setFill(\"#fff\");\r\n\r\n\t\tconst poweredByText = this.add.text(this.cameras.main.centerX, this.cameras.main.centerY - 25, \"Powered By\");\r\n\t\tpoweredByText.setOrigin(0.5, 0.5);\r\n\t\tpoweredByText.setFontFamily(\"monospace\").setFontSize(20).setFill(\"#fff\");\r\n\t\tthis.add.image(this.cameras.main.centerX, this.cameras.main.centerY, \"phaser_pixel_medium_flat\");\r\n\r\n\t\tthis.input.setDefaultCursor(\"pointer\");\r\n\t\tthis.input.on(\"pointerdown\", this.loadMainMenu, this);\r\n\r\n\t\tthis.time.addEvent({\r\n\t\t\t// Run after three seconds.\r\n\t\t\tdelay: 3000,\r\n\t\t\tcallback: this.loadMainMenu,\r\n\t\t\tcallbackScope: this,\r\n\t\t\tloop: false\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Load the next scene, the main menu.\r\n\t */\r\n\tprivate loadMainMenu(): void {\r\n\t\tthis.scene.start(MainMenu.Name);\r\n\t}\r\n}\r\n","import events from \"../Events\";\r\nimport Utilities from \"../Utilities\";\r\n\r\nexport default class UI extends Phaser.Scene {\r\n\t/**\r\n\t * Unique name of the scene.\r\n\t */\r\n\tpublic static Name = \"UI\";\r\n\tpanel: Phaser.GameObjects.Rectangle;\r\n\tscoreText: Phaser.GameObjects.Text;\r\n\r\n\tpublic create(): void {\r\n\t\tUtilities.LogSceneMethodEntry(\"UI\", \"create\");\r\n\t\tthis.setupUI();\r\n\t\tthis.setupisteners();\r\n\t\tthis.scene.pause();\r\n\t}\r\n\r\n\tsetupUI() {\r\n\t\tconst x = 10;\r\n\t\tconst y = 10;\r\n\t\tconst width = 125;\r\n\t\tconst height = 40;\r\n\t\tconst bgColor = 0xffffff;\r\n\t\t// create a rectangle with black border, white background with 0.5 alpha, and rounded corners\r\n\t\tthis.panel = this.add\r\n\t\t\t.rectangle(x, y, width, height, bgColor, 0.5)\r\n\t\t\t.setOrigin(0, 0)\r\n\t\t\t.setStrokeStyle(2, 0x000000);\r\n\t\t// add text to the panel\r\n\t\tthis.scoreText = this.add.text(x + 10, y + 10, \"Score: 0\", {\r\n\t\t\tfontSize: \"20px\",\r\n\t\t\tcolor: \"#000000\",\r\n\t\t\tfontFamily: \"VT323, monospace\",\r\n\t\t});\r\n\t}\r\n\r\n\tsetupisteners() {\r\n\t\tevents.on(\"coinStacked\", this.updateScore, this);\r\n\t}\r\n\r\n\tupdateScore(score: number) {\r\n\t\tthis.scoreText.setText(`Score: ${score}`);\r\n\t}\r\n}\r\n","export interface Tile {\r\n  x: number;\r\n  y: number;\r\n}\r\n\r\nexport default class Utilities {\r\n  /**\r\n   * Logs a particular message to the console.\r\n   * @param message Message to log.\r\n   */\r\n  public static Log(message: string): void {\r\n    console.log(new Date().toISOString() + \" : \" + message);\r\n  }\r\n\r\n  /**\r\n   * Logs the start of a method in a scene.\r\n   * @param sceneName Name of the scene.\r\n   * @param method Method called within the scene.\r\n   */\r\n  public static LogSceneMethodEntry(sceneName: string, method: string): void {\r\n    this.Log(\"Entered \" + sceneName + \" \" + method + \"()\");\r\n  }\r\n}\r\n","module.exports = Phaser;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(552);\n"],"names":["Coin","Phaser","Physics","Arcade","Image","constructor","scene","x","y","collideWorldBounds","super","this","setScale","physics","add","existing","setCollideWorldBounds","setOrigin","setGravityY","events","Events","EventEmitter","gameConfig","width","height","type","AUTO","parent","title","default","arcade","gravity","render","pixelArt","scale","mode","Scale","FIT","autoCenter","CENTER_BOTH","Game","config","LogSceneMethodEntry","Name","start","window","onload","Boot","Scene","preload","create","GameOver","score","setupUI","overlay","rectangle","cameras","main","text","centerX","centerY","fontSize","color","fontFamily","restartText","setInteractive","useHandCursor","on","console","log","stop","setColor","MainGame","init","movingCoins","stackedCoins","bottomCoins","coinsToSpawn","timesStacked","launch","setupBackground","setupCoins","setupClickEvents","update","topStackedCoin","forEach","coin","body","velocity","Math","round","row","displayHeight","length","firstCoin","index","displayWidth","setVelocityY","checkBoundaries","up","down","left","right","setVelocityX","cameraWidth","cameraHeight","world","bounds","bg","image","max","setScrollFactor","bg2","bg3","bg4","backgrounds","currentBgIndex","input","coinsStack","bind","spawnNewCoins","offset","direction","stacked","setVelocity","find","stackedCoin","stackedY","diff","abs","lastCoin","collider","obj1","obj2","push","emit","simulateScrolling","pause","yPosToSpawn","i","filter","coinToScroll","scrollY","tween","targets","duration","ease","onComplete","destroy","MainMenu","textYPosition","newGameText","setFontFamily","setFontSize","setFill","setAlign","settingsText","MainSettings","startYPosition","backText","Preloader","addProgressBar","load","path","bitmapFont","outerTextColor","progressBar","graphics","progressBox","fillStyle","fillRect","loadingText","make","style","percentText","assetText","value","setText","parseInt","clear","file","key","SplashScreen","poweredByText","setDefaultCursor","loadMainMenu","time","addEvent","delay","callback","callbackScope","loop","UI","setupisteners","panel","setStrokeStyle","scoreText","updateScore","Log","message","Date","toISOString","sceneName","method","module","exports","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","call"],"sourceRoot":""}